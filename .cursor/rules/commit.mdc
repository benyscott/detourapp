---
alwaysApply: false
---
# Assistant persona & coding rules (kept as guidance for the Cursor rule)
# You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks.
# Follow the user's requirements carefully & to the letter.
# First think step-by-step - describe plan, then confirm, then write code.
# (Persona and code guidelines included for clarity — this file implements the git automation requested.)

rules:
  - name: "Smart Git Commit (emoji + type prefix)"
    trigger: "/commit"
    description: "Stage all changes and create a commit where the message starts with emoji + type (e.g., 🐛 fix: description)."
    actions:
      - type: "shell"
        command: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Helper: print to stderr
          err() { printf "%s\n" "$*" >&2; }

          # 1) Ensure we are inside a git repo
          if ! git rev-parse --git-dir >/dev/null 2>&1; then
            err "✖ Not a git repository. Aborting."
            exit 2
          fi

          # 2) Determine if there are unstaged or staged changes
          local_status=$(git status --porcelain)
          if [ -z "$local_status" ]; then
            echo "ℹ No changes to commit."
            exit 0
          fi

          # 3) Stage everything (intent: commit all working-tree changes)
          git add .

          # 4) Get staged files list
          STAGED_FILES=$(git diff --cached --name-only || true)
          if [ -z "$STAGED_FILES" ]; then
            err "✖ No staged files after git add. Aborting."
            exit 3
          fi

          # 5) Build detection content (file names + staged diff content)
          FIRST_FILE=$(printf "%s\n" "$STAGED_FILES" | head -n1)
          FIRST_BASENAME=$(basename "$FIRST_FILE")
          STAGED_DIFF_CONTENT=$(git diff --cached --name-only | tr '\n' ' ' ; git diff --cached -U0 || true)

          # 6) Heuristic for commit type + emoji (order matters)
          TYPE="chore"
          EMOJI="🧩"
          # tests
          if printf "%s\n" "$STAGED_FILES" | grep -Ei "test|spec|__tests__|\\.spec\\.|\\.test\\." >/dev/null 2>&1 || printf "%s\n" "$STAGED_DIFF_CONTENT" | grep -Ei "assert|describe\\(|it\\(|jest|mocha" >/dev/null 2>&1; then
            TYPE="test"
            EMOJI="🧪"
          # docs
          elif printf "%s\n" "$STAGED_FILES" | grep -Ei "readme|docs|\\.md$|\\.rst$" >/dev/null 2>&1 || printf "%s\n" "$STAGED_DIFF_CONTENT" | grep -Ei "documentation|docstring|README" >/dev/null 2>&1; then
            TYPE="docs"
            EMOJI="📝"
          # style / css / ui
          elif printf "%s\n" "$STAGED_FILES" | grep -Ei "\\.css$|\\.scss$|\\.sass$|\\.less$|tailwind|\\.html$|\\.tsx?$|components" >/dev/null 2>&1 && printf "%s\n" "$STAGED_DIFF_CONTENT" | grep -Ei "className|tailwind|padding|margin|color|background" >/dev/null 2>&1; then
            TYPE="style"
            EMOJI="💄"
          # refactor
          elif printf "%s\n" "$STAGED_DIFF_CONTENT" | grep -Ei "refactor|rename|move|restructure" >/dev/null 2>&1; then
            TYPE="refactor"
            EMOJI="♻️"
          # feature / add
          elif printf "%s\n" "$STAGED_FILES" | grep -Ei "add|new|feature|\\.feature\\.|routes|pages|app" >/dev/null 2>&1 || printf "%s\n" "$STAGED_DIFF_CONTENT" | grep -Ei "new component|add feature|create" >/dev/null 2>&1; then
            TYPE="feature"
            EMOJI="✨"
          # fix / bug
          elif printf "%s\n" "$STAGED_DIFF_CONTENT" | grep -Ei "fix|bug|error|exception|throw|undefined|null|crash|panic|segfault" >/dev/null 2>&1 || printf "%s\n" "$STAGED_FILES" | grep -Ei "fix|bug|patch" >/dev/null 2>&1; then
            TYPE="fix"
            EMOJI="🐛"
          # fallback to chore
          else
            TYPE="chore"
            EMOJI="🧩"
          fi

          # normalize TYPE label for user-friendly short label (map test->test, docs->docs, style->style, refactor->refactor, feature->feature, fix->fix, chore->chore)
          TYPE_LABEL="$TYPE"

          # 7) Prompt user for a short description; allow leaving blank to auto-generate
          # Use `read -r` which is portable
          echo
          printf "Enter a short commit description (single-line). Leave empty to auto-generate: "
          IFS= read -r USER_MSG || true
          MSG="$USER_MSG"

          if [ -z "$MSG" ]; then
            # Auto-generate: pick a human-friendly verb depending on type + file basename
            case "$TYPE" in
              feature) GEN_VERB="Add" ;;
              fix) GEN_VERB="Fix" ;;
              docs) GEN_VERB="Update" ;;
              style) GEN_VERB="Style" ;;
              refactor) GEN_VERB="Refactor" ;;
              test) GEN_VERB="Add/Update tests for" ;;
              *) GEN_VERB="Update" ;;
            esac
            # sanitize FIRST_BASENAME (if empty, fallback to repo name)
            if [ -z "$FIRST_BASENAME" ]; then
              REPO_NAME=$(basename "$(git rev-parse --show-toplevel 2>/dev/null || echo repo)")
              MSG="$GEN_VERB $REPO_NAME"
            else
              MSG="$GEN_VERB $FIRST_BASENAME"
            fi
          fi

          # 8) Final commit message - format: "EMOJI type: description"
          # Ensure a single-line commit message with no embedded newlines
          SINGLE_LINE_MSG=$(printf "%s" "$MSG" | tr '\n' ' ' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')
          COMMIT_MESSAGE="${EMOJI} ${TYPE_LABEL}: ${SINGLE_LINE_MSG}"

          # 9) Do the commit (if there are staged changes)
          # Validate there's something staged
          if [ -z "$(git diff --cached --name-only)" ]; then
            err "✖ Nothing staged to commit after `git add .` — aborting."
            exit 4
          fi

          # Make the commit
          if git commit -m "$COMMIT_MESSAGE"; then
            echo "✅ Committed: $COMMIT_MESSAGE"
            git --no-pager show --no-color --name-only --pretty=format:"" HEAD | sed '/^$/d' | sed 's/^/  • /'
            exit 0
          else
            err "✖ git commit failed."
            exit 5
          fi